---
tags: [программирование, алгоритм]
---
# Алгоритмы поиска, которые должен знать каждый специалист по обработке и анализу данных

![](https://miro.medium.com/max/1240/1*X_GeTm4CcnPCYD8XD61DfA.jpeg)

В последние годы алгоритмы для решения задач [автоматического планирования и диспетчеризации](https://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B8_%D0%B4%D0%B8%D1%81%D0%BF%D0%B5%D1%82%D1%87%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F) стали вновь популярными в области машинного обучения. Понимание принципов их работы поможет увеличить производительность ваших моделей. К тому же, благодаря разработке таких мощных вычислительных технологий, как квантовых компьютеров, вскоре вновь будет использоваться искусственный интеллект, основанный на поиске.

## Что такое алгоритм поиска в искусственном интеллекте?

![](https://miro.medium.com/max/770/1*JrFAvOPCVsx7_i7N8ktVfg.png)

Алгоритм поиска — это не то же, что и поисковая служба

**Поиск** в рамках искусственного интеллекта — это процесс перемещения из **исходного состояния** в **целевое** через **промежуточные**.

Почти любая задача в рамках искусственного интеллекта может быть сформулирована при помощи этих терминов:

- **Состояние** — потенциальные исходы в задаче.
- **Переход** — смена одного состояния другим.
- **Исходное состояние** — состояние системы на момент начала поиска. С него мы начинаем поиск.
- **Промежуточное состояние** — состояние, в которое совершается переход на пути от исходного к целевому.
- **Целевое состояние** — состояние, при достижении которого поиск останавливается.
- **Область поиска** — множество состояний.

## Неинформированный поиск

![](https://miro.medium.com/max/330/1*d9fRPZao-wEaY7njfR9Pgw.png)
![](https://miro.medium.com/max/330/1*d9fRPZao-wEaY7njfR9Pgw.png)

Неинформированный поиск используется в том случае, когда нет информации о стоимости перехода из одного состояния в другое.

Существует три главных классических алгоритма неинформированного поиска:

- [**Поиск в глубину**](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83) — обходит область поиска, используя [LIFO-стек](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA) для определения следующей вершины.  
    **Преимущества:** хорошо работает в глубоких графах, эффективен по памяти.  
    **Недостатки:** есть вероятность зацикливания.
- [**Поиск в глубину с итеративным углублением**](http://www.rriai.org.ru/poisk-v-glubinu-s-iterativnyim-uglubleniem.html)— обходит область поиска, используя [LIFO-стек](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA) для определения следующей вершины. Когда алгоритм достигает заранее заданной глубины, он очищает стек, увеличивает счётчик достижения предельной глубины и запускает поиск заново из текущей вершины.
- [**Поиск в ширину**](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D1%88%D0%B8%D1%80%D0%B8%D0%BD%D1%83) — обходит область поиска, используя [FIFO-очередь](https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) для определения следующей вершины.

## Информированный поиск

![](https://miro.medium.com/max/770/1*_XmSnHzJK9LGExcm5kZMNw.png)

Информированный поиск используется в том случае, когда мы знаем точную стоимость или же оценку стоимости смены состояний.

- **UCS** — обходит область поиска, используя [очередь с приоритетом](https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_%D1%81_%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%BE%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) и текущий счёт. Текущий счёт для каждого состояния — стоимость достижения состояния из его родителя, то есть, из предыдущего состояния.
- [**A***](https://ru.wikipedia.org/wiki/A*) — обходит область поиска, используя [очередь с приоритетом](https://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_%D1%81_%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%BE%D0%BC_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) и текущий счёт. Текущий счёт для каждого состояния — стоимость достижения состояния через его родителя в пути и эвристическая оценка стоимости перехода из текущей вершины в целевую.  
    _Допустимое значение эвристической оценки_ должно удовлетворять следующим двум условиям: во-первых, эвристическая оценка должна быть меньше минимальной стоимости перехода из текущей вершины в целевую; во-вторых, она должна быть меньше эвристической оценки каждой из родительских вершин и стоимости достижения состояния в текущем пути.
- [**IDA***](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0#IDA*) — версия поиска A* с итеративным углублением.

## Локальный поиск

![](https://miro.medium.com/max/550/1*qCrIcS2tRXGqyG5qeqaw0w.gif)

Алгоритмы локального поиска используются в том случае, когда существует несколько возможных целевых состояний, но некоторые из них лучше других, то есть, возникает необходимость найти лучший из нескольких. Они довольно часто используются для оптимизации алгоритмов машинного обучения.

- [**Поиск восхождением к вершине**](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2%D0%BE%D1%81%D1%85%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC_%D0%BA_%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D0%BD%D0%B5) — жадный итеративный алгоритм, выбирающий следующим состоянием наименее затратное, пока оно не достигнет локального максимума.
- [**Алгоритм имитации отжига**](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%B8%D0%BC%D0%B8%D1%82%D0%B0%D1%86%D0%B8%D0%B8_%D0%BE%D1%82%D0%B6%D0%B8%D0%B3%D0%B0) — имитирует физический процесс, восходя к вершине, пока не достигнет локального максимума. При его достижении используется функция "температуры", которая определяет: стоит ли окончить поиск или продолжать его в попытке найти лучшее решение.
- [**GSAT**](https://en.wikipedia.org/wiki/WalkSAT) — алгоритм поиска восхождением к вершине на конъюнктивной нормальной форме. Для каждого возможного параметра подбирается случайное множество булевых значений. Если эти значения удовлетворяют предусловиям целевого состояния, то работа алгоритма завершена. Если же нет, то значения инвертируются таким образом, чтобы выражение соответствовало максимальному числу предусловий. Процесс повторяется заново с новым случайным множеством значений для ранее инвертированных переменных.
- [**Генетический алгоритм**](https://ru.wikipedia.org/wiki/%D0%93%D0%B5%D0%BD%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC) — генерируется исходная популяция состояний, из которой выбирается часть с наибольшим значением функции приспособленности. Оставшиеся состояния рандомно объединяются, немного мутируют, а затем вновь производится отбор лучших решений в следующее поколение.
- [**Лучевой поиск**](http://www.rriai.org.ru/lokalnyiy-luchevoy-poisk.html) — UCS с сохранением значений правдоподобной вероятности значений текущего и предыдущего шага модели. На каждом шаге алгоритм отбирает N наиболее вероятных состояний для дальнейшего поиска.
- [**Метод Монте-Карло**](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%9C%D0%BE%D0%BD%D1%82%D0%B5-%D0%9A%D0%B0%D1%80%D0%BB%D0%BE) — рандомизированный алгоритм поиска, который возвращает лучшее приближение верного результата поиска. Он довольно быстрый, но не точный.

![](https://miro.medium.com/max/770/1*A9f0Jzeq9cPfD1VJEUjEJg.png)

- [**Лас-Вегас**](https://ru.wikipedia.org/wiki/%D0%9B%D0%B0%D1%81-%D0%92%D0%B5%D0%B3%D0%B0%D1%81_(%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC)) — как и предыдущий, рандомизированный алгоритм, однако он прекращает свою работу лишь в том случае, если найден верный результат. Таким образом, алгоритм всегда точный, но зачастую медленный.

```
// алгоритм Лас-Вегас  
repeat:  
    k = RandInt(n)  
    if A[k] == 1,  
        return k;
```

- **Атлантик Сити** — ограниченный вероятностный алгоритм поиска с полиномиальным временем работы. Он объединяет в себе сильные и слабые стороны алгоритмов Монте-Карло и Лас-Вегас.

_Перевод статьи_ [_Aaron (Ari) Bornstein_](https://towardsdatascience.com/@aribornstein)_:_ [_AI Search Algorithms Every Data Scientist Should Know_](https://towardsdatascience.com/ai-search-algorithms-every-data-scientist-should-know-ed0968a43a7a)

## Ссылки

- [Источник](https://medium.com/nuances-of-programming/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%BA%D0%B0%D0%B6%D0%B4%D1%8B%D0%B9-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D1%81%D1%82-%D0%BF%D0%BE-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B5-%D0%B8-%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D1%83-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-8ffb944850cc)
- [00 Программирование](00%20Программирование.md)
